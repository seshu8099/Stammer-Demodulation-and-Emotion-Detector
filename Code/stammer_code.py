# -*- coding: utf-8 -*-
"""Stammer_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HyQmZRCcIxNIzOrkEZ2h9MzJ2U3ve0or
"""

pip install pydub gTTS pandas openai-whisper

from google.colab import drive
drive.mount('/content/drive')

import os
import re
import pandas as pd
from gtts import gTTS
from pydub import AudioSegment
from pydub.utils import mediainfo
import whisper

# === Set up directories ===
INPUT_DIR = "PATH TO YOUR DIRECTORY"
BASE_DIR = os.path.dirname(INPUT_DIR)

RAW_TEXT_DIR = os.path.join(BASE_DIR, "raw_transcripts")
CLEAN_TEXT_DIR = os.path.join(BASE_DIR, "cleaned_transcripts")
FLUENT_AUDIO_DIR = os.path.join(BASE_DIR, "fluent_outputs")
CSV_PATH = os.path.join(BASE_DIR, "stammer_processing_metrics.csv")

# === Create folders if not already present ===
os.makedirs(RAW_TEXT_DIR, exist_ok=True)
os.makedirs(CLEAN_TEXT_DIR, exist_ok=True)
os.makedirs(FLUENT_AUDIO_DIR, exist_ok=True)

# === Load Whisper model ===
print("üîÅ Loading Whisper model...")
model = whisper.load_model("base")

# === Utility Functions ===
def transcribe_audio(file_path):
    result = model.transcribe(file_path)
    return result['text']

def clean_stammered_text(text):
    text = re.sub(r'\b(\w+)(-\1)+\b', r'\1', text)  # syllable-level
    text = re.sub(r'\b(\w+)( \1\b)+', r'\1', text)  # word-level
    return text

def count_repetitions(text):
    word_repeats = re.findall(r'\b(\w+)( \1\b)+', text)
    syllable_repeats = re.findall(r'\b(\w)-(\1-)+\1\b', text)
    return len(word_repeats) + len(syllable_repeats)

def generate_fluent_audio(text, output_wav_path):
    mp3_path = output_wav_path.replace(".wav", ".mp3")
    tts = gTTS(text)
    tts.save(mp3_path)
    sound = AudioSegment.from_mp3(mp3_path)
    sound.export(output_wav_path, format="wav")
    return mp3_path

def get_audio_duration(path):
    try:
        info = mediainfo(path)
        return float(info['duration'])
    except Exception:
        return None

def detect_emotion_stub(text):
    return "neutral"

# === Process all files ===
results = []

for filename in os.listdir(INPUT_DIR):
    if filename.endswith(".wav"):
        base_name = os.path.splitext(filename)[0]
        input_path = os.path.join(INPUT_DIR, filename)
        raw_text_path = os.path.join(RAW_TEXT_DIR, f"{base_name}.txt")
        clean_text_path = os.path.join(CLEAN_TEXT_DIR, f"{base_name}_cleaned.txt")
        fluent_wav_path = os.path.join(FLUENT_AUDIO_DIR, f"{base_name}_fluent.wav")

        try:
            print(f"\nüîä Processing: {filename}")

            # Step 1: Transcribe
            raw_text = transcribe_audio(input_path)
            with open(raw_text_path, "w") as f:
                f.write(raw_text)

            # Step 2: Clean
            cleaned_text = clean_stammered_text(raw_text)
            with open(clean_text_path, "w") as f:
                f.write(cleaned_text)

            # ‚ùå Execution likely stopped just after this line, during Step 3 (below):
            # fluent_mp3_path = generate_fluent_audio(cleaned_text, fluent_wav_path)

fluent_wav_path = os.path.join("outputs", "fluent_wav", filename.replace(".wav", "_fluent.wav"))

import os

for root, dirs, files in os.walk("outputs"):
    for file in files:
        if file.endswith("_fluent.wav"):
            print("‚úÖ Found:", os.path.join(root, file))

fluent_wav_path = os.path.join("outputs", "fluent_wav", filename.replace(".wav", "_fluent.wav"))

from pydub import AudioSegment
import os

def convert_all_wav_to_mp3(input_dir, output_dir):
    os.makedirs(output_dir, exist_ok=True)

    for filename in os.listdir(input_dir):
        if filename.endswith(".wav"):
            wav_path = os.path.join(input_dir, filename)
            mp3_filename = filename.replace(".wav", ".mp3")
            mp3_path = os.path.join(output_dir, mp3_filename)

            try:
                audio = AudioSegment.from_wav(wav_path)
                audio.export(mp3_path, format="mp3")
                print(f"‚úÖ Converted: {filename} ‚Üí {mp3_filename}")
            except Exception as e:
                print(f"‚ùå Failed to convert {filename}: {e}")

# Call this with your actual path
convert_all_wav_to_mp3(
    input_dir="PATH TO YOUR DIRECTORY",
    output_dir="PATH TO YOUR DIRECTORY"
)

import pandas as pd

# Load the previously saved metrics
csv_path = "PATH TO YOUR DIRECTORY"
df = pd.read_csv(csv_path)

# Filter only successfully processed files
df = df[df["error"].isnull()]

# Create a comparison table
comparison = df[[
    "file",
    "input_duration_sec", "output_duration_sec",
    "raw_word_count", "clean_word_count",
    "raw_repeats", "cleaned_repeats",
    "repetition_reduction", "compression_ratio",
    "raw_words_per_sec", "cleaned_words_per_sec",
    "emotion"
]]

# Save or display
comparison_path = "PATH TO YOUR DIRECTORY"
comparison.to_csv(comparison_path, index=False)
print(f"‚úÖ Comparison summary saved to: {comparison_path}")

# Show a preview
comparison.head()

print(df.shape)
print(df.columns)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load data
csv_path = "PATH TO YOUR DIRECTORY"
df = pd.read_csv(csv_path)

# Clean and filter
numeric_cols = [
    "input_duration_sec", "output_duration_sec",
    "raw_word_count", "clean_word_count",
    "raw_repeats", "cleaned_repeats",
    "repetition_reduction", "compression_ratio",
    "raw_words_per_sec", "cleaned_words_per_sec"
]
df[numeric_cols] = df[numeric_cols].apply(pd.to_numeric, errors='coerce')
df.dropna(subset=numeric_cols, inplace=True)

# Pick top 5 longest files by input duration
df_top = df.sort_values(by="input_duration_sec", ascending=False).head(5)

# Setup
sns.set(style="whitegrid")
plt.figure(figsize=(14, 10))

# Plot 1: Duration Comparison
plt.subplot(2, 2, 1)
dur = df_top[["file", "input_duration_sec", "output_duration_sec"]].melt(id_vars="file", var_name="Type", value_name="Duration (sec)")
sns.barplot(data=dur, y="file", x="Duration (sec)", hue="Type")
plt.title("üéß Input vs Output Duration")

# Plot 2: Word Count
plt.subplot(2, 2, 2)
wc = df_top[["file", "raw_word_count", "clean_word_count"]].melt(id_vars="file", var_name="Type", value_name="Word Count")
sns.barplot(data=wc, y="file", x="Word Count", hue="Type")
plt.title("üìù Raw vs Cleaned Word Count")

# Plot 3: Repetition Reduction
plt.subplot(2, 2, 3)
sns.barplot(data=df_top, y="file", x="repetition_reduction", palette="coolwarm")
plt.title("üîÅ Repetition Reduction (Fraction)")
plt.xlabel("Repetition Reduction")

# Plot 4: Words Per Second
plt.subplot(2, 2, 4)
wps = df_top[["file", "raw_words_per_sec", "cleaned_words_per_sec"]].melt(id_vars="file", var_name="Type", value_name="WPS")
sns.barplot(data=wps, y="file", x="WPS", hue="Type")
plt.title("‚è±Ô∏è Words per Second: Raw vs Cleaned")

# Finish
plt.tight_layout()
plt.show()